1. Software engineering: 
is a discipline that involves the application of engineering principles, techniques, and methodologies to the design, development, 
testing, and maintenance of software systems. It encompasses a systematic approach to 
create high-quality, reliable, and efficient software solutions that meet user requirements within specified constraints such as time 
and budget. Key characteristics:
	+ Functionality
	+ Reliability
	+ Efficiency
	+ Scalability
	+ Usability
	+ Maintainability
	+ Portability
	+ Security
	+ Compatibility: 
		Software should be compatible with different hardware platforms, operating systems, and software environments to ensure interoperability and ease of integration with other systems and applications.
Activities:
	Requirements Analysis: Understanding and documenting what the software needs to do.
	Design: Creating a blueprint for the software architecture.
	Implementation: Writing the actual code.
	Testing: Verifying that the software works correctly.
	Maintenance: Keeping the software up-to-date and fixing issues.


2. A software process: 
refers to the methods and techniques used to develop and maintain software.
	+ A Software Process Framework: 
		is basically a blueprint that defines the order and structure for developing software. It outlines the steps involved in the 
		software development lifecycle, ensuring a smooth and efficient process from start to finish.
	+ Umbrella activities: 
		in software development are essentially the behind-the-scenes tasks that support the entire development process.  
			- Risk mangament
			- Configuration Management
			- Project Tracking and Control:
			- Quality Assurance


3. The software development life cycle (SDLC): 
is a structured process that is used to design, develop, and test good-quality software. SDLC, or software development life cycle is a 
methodology that defines the entire procedure of software development step-by-step. The goal of the SDLC life cycle model is to deliver 
high quality, maintainable software that meets the user’s requirements. 


3. Capability maturity model: 
CMM helps assess an organization’s maturity in software development processes. It provides guidelines to enhance process maturity. 
CMM defines five maturity levels, each representing a process capability level.

	Level 1 (Initial): Chaotic processes with no defined structure.

	Level 2 (Repeatable):  
		Processes are documented and standardized / managed to some extent. Basic project 
		management practices are in place to track cost, schedule, and functionality. However, 
		processes may still be reactive and not fully controlled. 

	Level 3 (Defined):  
		Standardized processes across projects. Standard procedures exist for project management, quality assurance, and other key 
		processes.

	Level 4 (Managed): 
		Processes are measured and controlled using statistical and 
		other quantitative techniques. Metrics are used to monitor process performance, and 
		processes are continuously optimized to improve quality and efficiency.

	Level 5 (Optimizing): 
		The organization focuses on continuous process improvement and 
		innovation. Processes are agile, adaptable, and responsive to changing needs and 
		opportunities. Best practices are identified and shared across the organization to drive 
		further improvements.
	
Benefits of CMM:
	Resource Optimization: Efficient use of resources (money, labor, time).
	Benchmarking: Formal framework for self-evaluation and comparison.
	Quality Management: Emphasizes quality assurance and control.
	Process Enhancement: Gradual process improvement.
	Increased Output: Boosts productivity without compromising quality.


4. The Waterfall Model: 
is a classic software development life cycle (SDLC) model that follows a structured, sequential approach for project management and 
software development. We can imagine waterfall in the following way:  
	“ Once the water starts flowing over the edge of the cliff, it starts falling down the mountain and the water cannot go back up ” 
Similarly, waterfall model also works, once one phase of development is completed then we move to the next phase but cannot go back to 
the previous phase. In the waterfall model, the output of one phase serves as the input for the other phase. 

	Phases:
		+ Reuqirements
		+ Design
		+ Implement
		+ Verification
		+ Maintanance

	Advantages:
		Clarity and Simplicity: The linear structure provides a straightforward foundation for project development.
		Suited for projects with clear and stable requirements.
	Disadvantages:
		Inflexible: Changes are difficult once a phase is complete.
		Risk of Late Discoveries: Issues may arise late in the process.
		Not Ideal for Complex Projects: May not handle complex, evolving requirements well.

Iterative waterfall model is an extension of it, which alows Iteratively fixing and improveing the software flexibly.

5. The Prototype Model: 
in software engineering is a developmental approach where a prototype is created, tested, and refined based on feedback. Involves building 
a preliminary version of the final software. This prototype serves as a basic model which refined based on user input.
	Phases:
		+ Reqiurments
		+ Quick Design
		+ Build a prototype
		+ User evaluation
		+ Refining the prototype
		+ Implemnt and maintanance
One problem in this model is that if the end users are not satisfied with the prototype model, then a new prototype model is created 
again, due to which this model consumes a lot of money and time.


6. The V-Model: 
in software engineering is a development process that extends the waterfall model. It emphasizes testing and validation at every stage 
of the development process. The V-Model gets its name from its “V” shape, representing parallel development and testing phases.
Unlike the linear waterfall model, the V-Model bends upward after the coding phase.
	Same Advantages and Disadvantages as of Waterfall model: 
		+ Thorough testing ensures high-quality software


7. Incremental development model: 
First, a simple working system implementing only a few basic features is built and then that is delivered to the customer. Then 
thereafter many successive iterations / versions are implemented and delivered to the customer until the desired system is released. 


8. The evolutionary model: 
is a combination of the Iterative and Incremental models of the software development life cycle. The Evolutionary Model divides the 
development cycle into smaller, incremental waterfall models. Users get access to the product at the end of each cycle.
Feedback from users helps in planning the next cycle, allowing for changes and adaptations.
The software product evolves over time. This model is suitable for products which are prone to constant redesigns and new feature 
additions. (draw a down flowing diagram with all phases below)
	Phases:
		+ Same till designing
		+ Iterative process:
			+ Develop a version
			+ Deliver the version of product to the user
			+ Take user feedback on it
			+ Incorporate the feedback in the developement
		+ Deliver completed project


9. Spiral model:
This model has characteristics of both of iterative and waterfall model. This model is used in projects which are large and complex.  
It is named as Spiral as in this model we start building the software and then take multiple iterations or loops to deliver the better 
version of the software, its figure, it looks like a spiral, in which a long-curved line starts from the centre point and makes many 
loops around it.  The most special thing about this model is that risks are identified in each phase and they are resolved through 
prototyping. This feature is also called Risk Handling. (draw a spiral diagram with 4 segments like graphs and name all phases)


10. RAD model (rapid application developement):
The methodology of RAD model is similar to that of incremental or waterfall model. It is used for small projects. 
If the project is large then it is divided into many small projects and these small projects are 
planned one by one and completed. In this way, by completing small projects, the large project gets ready quickly. 
In this model large project is divided into multiple small projects each of which are completed indedpendently acc. to the time
deadline and the then all modules are joined together to deliver the final product. The main objective of RAD model is to reuse code, 
components, tools, processes in project development.


10. Concurrent paradigm: 
is a programming paradigm that focuses on executing multiple processes concurrently. It aims to enhance the efficacy and performance of 
software systems by utilizing parallel processing


11. Agile: 
is a project management approach that emphasizes adaptability, collaboration, and continuous improvement. It follows the iterative as 
well as incremental approach that emphasizes the importance of delivering of working product very quickly. Below are steps of agile 
process:
	Requirements Gathering: Define project requirements, evaluate feasibility, and plan time and effort.
	Design: Work with stakeholders to define requirements and create high-level diagrams.
	Construction/Iteration: Developers start working on the project, deploying a working product in stages.
	Testing: Quality Assurance examines the product for bugs.
	Deployment: The product is released to the user environment.
	Feedback: Gather feedback and make improvements
AGILE PRINCIPLES: 
	- CUSTOMER SATISFACTION  
	- WELCOME THE CHANGES  
	- DELIVER WORKING SOFTWARE FREQUENTLY  
	- WORKING TOGETHER DAILY  
	- MOTIVATED INDIVIDUALS  
	- FACE TO FACE CONVERSATION  
	- WORKING SOFTWARE  
	- TECHNICAL EXCELLENCE  
	- SELF ORGANISING  
	- SIMPLICITY
	- SUSTAINABLE DEVELOPEMNT


12. Extreme Programming (XP): 
is an agile software development framework that aims to produce higher quality software without compromising the developer experience.
The extreme programming model recommends taking the best practices that have worked well in the past in program development projects.
Below are the best prcatices that have been recognized in the extreme programming model:
	+ Code reviews
	+ Test-Driven Development
	+ Pair Programming
	+ Coding Standards
	+ Refactoring
	+ Customer Involvement
	+ Incremental Development
	+ Continues integration
	+ Simplicity
	+ Design
	+ Integration testing


13. Scrum: 
is an agile team collaboration framework commonly used in software development and other industries. It provides a structured approach to 
managing complex projects, emphasizing teamwork, transparency, and adaptability. The team working on the project under scrum methodology
consists of:
	Product Owner: Represents stakeholders, defines product requirements, and prioritizes work.
	Scrum Master: Facilitates the Scrum process, removes obstacles, and ensures adherence to Scrum principles.
	Developers: The team responsible for creating the product increment.
A few key terms / events of scrum framework:
	Sprint: During sprints, the Scrum team completes the goals and objectives outlined for that particular time frame.
	Sprint Planning: The team plans for the upcoming sprint.
	Daily Scrum (Stand-up): A daily meeting where team members share progress and discuss any impediments.
	Sprint Review: The team demonstrates completed work to stakeholders.
Scrum decisions are based on observation, experience, and experimentation. The framework encourages learning through small experiments and 
adapting as needed.


// ----------------------------------------------------------------------------------------------------------------------------------- //
																MODULE-2
// ----------------------------------------------------------------------------------------------------------------------------------- //


1. Functional Requirements:
- These are the specific features and behaviors that the system must provide to meet the user’s needs.
- Functional requirements answer the question: “What should the software system do?”, Examples of functional requirements include:
	- User authentication (e.g., login functionality).
	- Order processing (e.g., adding items to a shopping cart).
	- Search functionality (e.g., searching for products).
- These requirements are directly visible in the final product and are typically captured in use cases.


2. Non-Functional Requirements:
- These define the quality attributes that the system must satisfy. They focus on how the system performs rather than what it does.
- These requirements address aspects beyond functionality and deal with issues like:
	- Performance: How quickly the system responds to user requests.
	- Security: Ensuring data protection and access control.
	- Usability: How user-friendly the system is.
	- Reliability: System availability and error handling.
	- Scalability: Handling increased load or users.
	- Maintainability: Ease of maintaining and updating the system.
- Non-functional requirements are often specified by technical experts (e.g., architects, developers).
- They are essential for ensuring a robust and high-quality system.


3. Requirements engineering: 
is a crucial part of software development. It involves identifying, analyzing, specifying, validating, and managing the needs and 
expectations of stakeholders for a software system. Let’s break down the process:
	+ Inception: 
		This is the initial stage where the project is conceptualized and the goals 
		and objectives are defined. It involves identifying the problem to be solved and determining the overall scope of the project. 
	+ Elicitation: 
		Elicitation involves gathering requirements from stakeholders. However, there can be several challenges during this stage: 
		• Problems of scope: Stakeholders may have different ideas about what the 
			system should do, leading to scope creep or conflicting requirements. 
		• Problems of understanding: Stakeholders may have difficulty articulating their 
			needs or may not fully understand the capabilities and limitations of the system. 
		• Problems of volatility: Requirements may change frequently due to evolving 
			business needs, technological advancements, or changing market conditions. 
	+ Elaboration: 
		In this stage, the gathered requirements are analyzed, refined, and 
		detailed further. The goal is to ensure that the requirements are complete, consistent, and unambiguous. 
	+ Negotiation: 
		Requirements often involve trade-offs between conflicting priorities, 
		such as cost, schedule, and functionality. Negotiation involves reaching consensus 
		among stakeholders and finding compromises that satisfy the needs of all parties involved. 
	+ Specification: 
		This stage involves documenting the requirements in detail using 
		various techniques such as use cases, user stories, and formal requirement documents. 
		The goal is to create a clear and unambiguous description of what the system is expected to do. 
	+ Validation: 
		Validation involves ensuring that the documented requirements accurately 
		reflect the needs and expectations of stakeholders and are feasible to implement. It 
		ensures that the requirements are testable and verifiable. 
	+ Requirements Management: 
		This stage involves maintaining and controlling changes 
		to requirements throughout the software development lifecycle. It includes tracking 
		changes, managing dependencies, and ensuring that requirements remain aligned with project goals and objectives. 


4. A Software Requirements Specification (SRS): 
is a crucial document that outlines the requirements for developing a software system. SRS is a kind of agreement between the customer 
and the company, which contains complete information about the requirement desired by the customer and the product made by the company.
In other words, SRS is a document which describes what will be the features of the software and what will be its behaviour.
The SRS provides a common communication channel between stakeholders, so that everyone agrees as to what the project aims at. It reduces 
ambiguity and the risks of misunderstandings among team members in clearly defining requirements. It serves below purposes:
	+ Clarity and Understanding
	+ Basis for Project Planning
	+ Guidance for Development Teams
	+ Facilitates Testing and Quality Assurance
	+ Change Management
	+ Client and Stakeholder Satisfaction
	+ Risk Mitigation
	+ Enhanced Collaboration


5. 3P's:
	+ People: 
		People refer to the human resources involved in the software development 
		process. This includes developers, testers, project managers, stakeholders, and end
		users. The success of a software project heavily depends on the skills, experience, 
		motivation, and collaboration of the people involved. Effective communication and 
		teamwork among team members are essential for delivering high-quality software on 
		time and within budget. 
	+ Process: 
		Process refers to the methodologies, frameworks, and practices used to 
		manage and execute software development projects. Examples of software 
		development processes include Waterfall, Agile, Scrum, and DevOps. Each process 
		has its own set of principles, practices, and tools for planning, executing, monitoring, 
		and controlling software development activities. Choosing the right process and 
		adapting it to the specific needs of the project is crucial for achieving project success. 
	+ Product: 
		Product refers to the software or system being developed. This includes its 
		features, functionality, quality, and usability. The goal of software development is to 
		deliver a product that meets the needs and expectations of its users while adhering to 
		project requirements, budget, and schedule constraints. Product quality assurance, 
		testing, and validation are important aspects of ensuring that the final product meets 
		its intended purpose and provides value to its users.


6. Software metrics:

	+ Direct measures /  Size oriented metrics: 
		of the software process include cost and effort applied. Direct measures of the product include  
			lines of code (LOC) produced, 
			execution speed, 
			memory size, and 
			defects reported over some set period of time,
			No of Persons​,
			No of errors,
			cost per line of code (LOC)

	+ Indirect measures / Function oriented metrics:
		of the product include functionality, quality, complexity, efficiency, reliability,  maintainability,and many other “–abilities”


7. The COCOMO (Constructive Cost Model): 
is a widely used software cost estimation model primarily based on the size of the software project, typically measured in lines of code 
(LOC). It helps predict various project parameters, including size, effort, cost, time, and quality. 

	+ Types of project:
		Organic: 
			A software project is said to be an organic type if the team size required is adequately small, the problem is well understood 
			and has been solved in the past and also the team members have a nominal experience regarding the problem.
		Semi-detached: 
			Falls between organic and embedded, requiring more experience and guidance. The projects classified as Semi-Detached are 
			comparatively less familiar and difficult to develop compared to the organic ones and require more experience better guidance 
			and creativity
		Embedded: 
			Complex projects demanding creativity, large teams, and significant experience

	Types COCOMO:

		+ Basic COCOMO:
			This is the simplest and fastest method for making preliminary estimations. It uses a formula with two constants (a and b) and 
			the project size in KLOC (Kilo Lines of Code) as the main input. The constants (a and b) vary depending on the type of software 
			project (organic, semi-detached, or embedded).
			-Advantages: Quick and easy to use, suitable for rough estimates in early stages.
			-Disadvantages: Ignores project complexities, least accurate among COCOMO models.

		+ Intermediate COCOMO:
			This builds upon Basic COCOMO by introducing 15 "cost drivers" that affect the project effort and schedule. These cost 
			drivers consider factors like:
				Product factors: Complexity, reliability, size of the primary memory.
				Platform factors: The maturity of the target environment and the experience with the hardware/software.
				Personnel factors: The capability and experience of the team.
				Project factors: The type of development approach and the level of customer involvement.
				Environmental factors: The constraints imposed by the work environment (e.g., tools, automation).
			-Advantages: Considers project complexities, improves estimation accuracy over Basic COCOMO.
			-Disadvantages: Requires more project information to assess the cost drivers, may not capture all project nuances.

		+ Detailed COCOMO:
			This is the most granular level, offering the most detailed and potentially most accurate effort and time estimates. It breaks 
			down the entire software development life cycle (SDLC) into phases and applies COCOMO principles to each phase individually. 
			This allows for a more precise assessment of the effort required for each development stage.
			-Advantages: Most accurate estimation among COCOMO models, considers complexities throughout the SDLC.
			-Disadvantages: Most complex and time-consuming to implement, requires significant project details and expertise.

	+ COCOMO Phases:
		Planning and requirements
		System design
		Detailed design
		Module code and test
		Integration and test
		Cost Constructive model

	+ Importance of the COCOMO Model:
		Cost Estimationent
		Resource Management
		Project Planning
		Risk management
		Benchmarking		
		Resource Optimization

	+ Disadvantages of the COCOMO Model

		-Assumes that the size of the software is the main factor that determines the cost and effort of a software project, which may 
		not always be the case.
	
		-Does not take into account the specific characteristics of the development team, which can have a significant impact on the 
		cost and effort of a software project.

		-This does not provide a precise estimate of the cost and effort of a software project, as it is based on assumptions and 
		averages.


8. The COCOMO-II: 
is the revised version of the original Cocomo (Constructive Cost Model) and is developed at the University of Southern California. This 
model calculates the development time and effort taken as the total of the estimates of all the individual subsystems. In this model, 
whole software is divided into different modules.


// ----------------------------------------------------------------------------------------------------------------------------------- //
																MODULE-3
// ----------------------------------------------------------------------------------------------------------------------------------- //


1. The software design process: 
is a systematic approach to creating a blueprint for software. It involves translating user requirements into a structured design that 
developers can implement. It is an neccesary step for creating a smooth workflow for product / software developement.
	- UI design
	- Arhitectural design
	- Component design
	- Data design


2. Golden Rules: 
	<three golden rules: responsiveness, clear structure, and effective error handling>
of user interface (UI) design are a set of principles aimed at creating effective and user-friendly interfaces. These rules help ensure 
that users can interact with software applications efficiently, effectively, and with satisfaction. Here are the key principles often 
referred to as the golden rules of UI design:
	+ Consistency:
		Ensure that the interface maintains consistency throughout the application. This includes consistent use of colors, fonts, button
		styles, and terminology. Consistency helps users quickly learn and understand the interface.
	+ Simple and Natural Dialogue:
		Design the interface to present information in a natural and logical order. Use language that is clear and concise, avoiding 
		technical jargon or complex terminology. The goal is to make interactions feel straightforward and intuitive.
	+ Speak the User's Language:
		Use terms and concepts familiar to the user rather than system-oriented terms. This involves understanding the target audience 
		and tailoring the interface to their level of knowledge and expertise.
	+ Minimize User Memory Load:
		Reduce the cognitive load on users by minimizing the amount of information they need to remember between interactions. Interfaces 
		should provide visual cues, prompts, and reminders to aid users.
	+ Provide Feedback:
		Offer immediate and clear feedback for user actions. Whether it’s a button press, form submission, or system error, feedback lets 
		users know that the system is processing their input and keeps them informed of the outcome.
	+ Offer Error Prevention and Recovery:
		Design the interface to prevent errors where possible and offer simple recovery mechanisms when errors occur. This can include 
		confirmation dialogs, undo options, and clear error messages with guidance on how to correct issues.
	+ Provide Clearly Marked Exits:
		Allow users to easily exit or undo actions without confusion. This helps users feel in control and confident that they can 
		backtrack if they make a mistake.
	+ Permit Easy Reversal of Actions:
		Users should be able to undo their actions easily. This reduces anxiety and encourages exploration since users know they can 
		revert changes if needed.
	+ User-centered design: 
		User interface design should be focused on the needs and preferences of the user. This involves understanding the user’s goals, 
		tasks, and context of use, and designing interfaces that meet their needs and expectations.
	+ Reduce Short-Term Memory Load:
		Avoid requiring users to remember information across different screens or sessions. Use visual aids, context-sensitive help, and 
		keep necessary information visible or easily accessible.


3. Key steps involved in user interface design:
	+ User, Task, Environmental Analysis, and Modeling:
		Understand the profile of users who will interact with the system.
		Identify user categories based on their requirements.
		Analyze the tasks users perform to establish system goals.
		Consider the physical work environment where the interface will be located.
	+ Interface Design:
		Define the set of interface objects (control mechanisms) for desired tasks.
		Specify action sequences (user scenarios) and system states.
		Follow the three golden rules: responsiveness, clear structure, and effective error handling.
	+ Interface Construction and Implementation:
		Create a prototype for evaluation.
		Use a User Interface toolkit to build windows, menus, and other interactive elements


// ----------------------------------------------------------------------------------------------------------------------------------- //
																MODULE-4
// ----------------------------------------------------------------------------------------------------------------------------------- //


1. Risk Mitigation, Monitoring, and Management (RMMM): 
is a systematic approach used in software engineering to identify, assess, and address potential risks throughout the software development
lifecycle. As part of the overall project plan project manager generally uses this RMMM plan. In some software teams, risk is documented 
with the help of a Risk Information Sheet (RIS)

	+ Risk Mitigation : 

		-Identification: The first step is to identify all potential risks that could affect the project. These can include technical 
			risks, project management risks, organizational risks, and external risks.

		-Analysis: Once identified, each risk is analyzed to determine its likelihood and potential impact on the project. This often 
			involves qualitative and quantitative analysis.

		-Planning: After analyzing the risks, strategies are developed to mitigate them. Mitigation strategies may include avoiding the 
			risk, transferring the risk, reducing the likelihood of the risk occurring, or reducing the impact of the risk.

	+ Risk Monitoring : 

		-Tracking: Continuous monitoring of identified risks is essential. This involves keeping an eye on risk indicators and triggers 
			that might signal the likelihood of a risk event occurring.

		-Reviewing: Regular reviews and audits are conducted to reassess risks and the effectiveness of the mitigation strategies. This 
			can be done through scheduled meetings, status reports, and risk logs.

		-Updating: (RIS) needs to be updated regularly based on new information, changes in 
			the project scope, or when new risks are identified.

	+ Risk Managment:
		This involves allocating resources, assigning responsibilities, and ensuring that everyone involved is aware of their role in 
		managing risks.
		Response Planning: Developing specific response plans for risks that materialize is part of management. This includes having 
		contingency plans and predefined actions to address the risks effectively.
		Communication: Effective communication is key to managing risks. Keeping all stakeholders informed about the risks, the status of 
		mitigation efforts, and any changes to the risk management plan ensures that everyone is prepared and can respond appropriately.

	+ Drawbacks of RMMM:
		It incurs additional project costs.
		It takes additional time.
		For larger projects, implementing an RMMM may itself turn out to be another tedious project.
		RMMM does not guarantee a risk-free project, infact, risks may also come up after the project is delivered.


2. Software Configuration Management (SCM): 
is a critical aspect of software engineering that focuses on controlling and managing changes in software projects. SCM aims to ensure 
that software products are consistent, traceable, and reproducible throughout the software development lifecycle. 
	+ What it Does:
		+Tracks Changes: An SCM system keeps a history of all changes made to the project's files. This allows developers to see who made 
			a change, what the change was, and when it was made.
		+Maintains Control: The SCM process helps to ensure that only authorized developers can make changes to the codebase. This helps 
			to prevent accidental or unauthorized changes.
		+Enables Collaboration: With SCM, multiple developers can work on the same project at the same time. The SCM system helps to merge 
			changes from different developers without conflicts.
		+Improves Efficiency: By tracking changes and maintaining a history, the SCM process makes it easier for developers to find and 
			fix bugs. It also allows them to revert to previous versions of the code if necessary.

	+ The Steps Involved:
		+Configuration Identification: This involves identifying all the different elements that make up the software project, such as 
			source code, documentation, and test data.
		+Version Control: This is the heart of the SCM process. It involves keeping track of all the different versions of the project's 
			files. A version control system (VCS) is a tool that automates this process. Popular VCS options include Git and Subversion.
		+Change Control: This involves establishing a process for reviewing and approving changes to the codebase. This helps to ensure 
			that only high-quality changes are integrated into the project.
		+Status Accounting: This involves keeping track of the current status of the project. This includes information on which version 
			of the code is currently being worked on, what bugs have been fixed, and what new features are being developed.
		+Configuration Audits: This involves periodically reviewing the project's configuration to ensure that it is still meeting its 
			requirements.
			
	+ Benefits of Using SCM:
		Improved code quality
		Easier collaboration
		Increased efficiency
		Better bug tracking and fixing
		Simplified rollbacks to previous versions


3. A formal technical review (FTR): 
is a systematic process for evaluating a software artifact,  such as design documents, code, or test plans. It is a quality control 
activity conducted by a group of peers to identify defects, improve quality, and verify compliance with established standards. 
+ Here are the objectives of an FTR in software engineering:
	Uncover errors in logic, function, or implementation.
	Verify the software meets its requirements.
	Ensure the software adheres to predefined standards.
	Promote a uniform development approach.
	Enhance project manageability.
	Risk Mitigation
	Quality Assurance
	Consistency and Compliance: Verify that all procedures, coding standards, and policies are followed.
	Foster knowledge sharing among developers, especially junior engineers who can learn from more experienced reviewers.


4. Walkthrough:
in software testing is a review process where the author of the code or document guides peers, managers, and fellow team members through 
the material. The goal is to gather feedback, identify defects, and reach a consensus. Unlike formal inspections, walkthroughs are 
informal and open-ended discussions.
	+ Advantages and Objectives of Walkthrough:  
		 To detect defects in developed software products. 
		 To fully understand and learn the development of software products. 
		 To properly explain and discuss the information present in the document. 
		 To verify the validity of the proposed system. 
		 To give suggestions and report them appropriately with new solutions and ideas. 
		 To provide an early “proof of concept”. 


5. Software Quality Assurance (SQA): 
is simply a way to assure quality in the software. s. It runs parallel to software development and ensures that processes, procedures, 
and standards are suitable for the project. SQA are typically done by some third party organization to check wheather an software
product of the company emplies all industry standards, compliance and safety regulations, etc.
	+ Elements of SQA:
		-Standards: Ensures adherence to industry standards
		-Reviews and audits: Technical reviews are a quality control activity performed by software engineers for software engineers. Their 
			intent is to uncover errors. Audits are a type of review performed by SQA personnel (people employed in an organization) with 
			the intent of ensuring that quality guidelines are being followed for software engineering work.
		-Testing: Properly planned and efficient testing to find errors.
		-Security management: SQA ensures that appropriate process and technology are used to achieve software security.
		-Risk management: The SQA organization ensures that risk management activities are properly conducted and that risk-related 
			contingency plans have been established.
	+ Types of Quality Assurance Testing:
		Functional Testing: Validates functionality against requirements.
		Performance Testing: Assesses system performance under various conditions.
		Security Testing: Identifies vulnerabilities and ensures data protection
	+ Software Quality Assurance (SQA) focuses on:
		software’s portability
		software’s usability
		software’s reusability
		software’s correctness
		software’s maintainability
		software’s error control


// ----------------------------------------------------------------------------------------------------------------------------------- //
																MODULE-4
// ----------------------------------------------------------------------------------------------------------------------------------- //


1. Reverse engineering: 
is the process of analyzing an existing software program to understand its internal workings. It's essentially taking something apart to 
understand how it works, like disassembling a toy car to see how the engine makes the wheels move. There are many reasons why someone 
might reverse engineer software. Here are a few common reasons:	
	+ To understand how a program works in order to modify it: 
		This could be useful for fixing bugs, adding new features, or making the program work on a different platform.
	+ To identify security vulnerabilities
	+ To create compatible software or hardware
	+ To learn from the design of the program: 
		Reverse engineering can be a great way to learn about different software architectures and design patterns. This can be helpful 
		for software developers who are looking to improve their own coding skills.
Reverse engineering can be a complex and time-consuming process. It often involves a combination of static analysis 
(examining the code without running it) and dynamic analysis (running the code and observing its behavior). 


2. Forward engineering = Software developement


3. Re-engineering: 
also known as software re-engineering or software renovation, is
the process of updating, modernizing, or improving existing software systems.
Instead of starting from scratch, re-engineering involves analyzing and
restructuring existing software to enhance its functionality, performance, maintainability, or other aspects. 
Here's how it typically works:
	+ Assessment: 
		The first step in re-engineering is to assess and analyzing its code, 
		architecture, documentation, and functionality to identify areas that need improvement or updating.
	+  Understanding: 
		Next, developers and engineers work to understand the existing software system thoroughly. They examine how it works, why it was 
		built the way it was.
	+  Goals and Requirements: 
		Based on the assessment and understanding of the
		existing system, stakeholders define the goals and requirements for the
		re-engineering project. These could include improving performance, adding new
		features, modernizing technology, or enhancing user experience.
	+  Restructuring: 
		Once the goals and requirements are clear, developers begin the
		process of restructuring the software. This may involve redesigning the
		architecture, refactoring the code, replacing outdated components, or integrating
		new technologies.
	+ Testing
	+ Deployment
	+ Maintanance


4. 4. Software testing: 
is the process of evaluating a software application to identify if it meets specified requirements and to identify any defects. 
The following are common testing strategies: 
	+Black box testing – Tests the functionality of the software without looking at the internal code structure
	+White box testing – Tests the internal code structure and logic of the software. 
	+Unit testing – Tests individual units or components of the software to ensure they are functioning as intended
	+Integration testing – Tests the integration of different components of the software to ensure they work together as a system
	+Functional testing – Tests the functional requirements of the software to ensure they are met
	+System testing – Tests the complete software system to ensure it meets the specified requirements
	+Acceptance testing – Tests the software to ensure it meets the customer’s or end-user’s expectations
	+Regression testing – Tests the software after changes or modifications have been made to ensure the changes have not introduced new 
		defects
	+Performance testing – Tests the software to determine its performance characteristics such as speed, scalability, and stability
	+Security testing – Tests the software to identify vulnerabilities and ensure it meets security requirements

The process involves several key steps:- 
		- Requirement Analysis: 
			Understanding the requirements and expectations of the software.
		- Test Planning: 
			Creating a comprehensive test plan that outlines the objectives, scope, resources, and schedule for testing.
		- Test Design: 
			Designing test cases and scenarios based on requirements, covering various functionalities and potential use cases.
   		- Test Execution: 
			Running the tests according to the test plan and documenting the results.
		- Defect Reporting: 
			Identifying and documenting any defects or issues encountered during testing.
		- Defect Resolution: 
			Addressing and fixing the reported defects, followed by retesting to ensure they are resolved.
		- Regression Testing
		- Test Closure: 
			Summarizing the testing process, documenting lessons learned, and preparing test closure reports

	
















































// ----------------------------------------------------------------------------------------------------------------------------------------------------- //
// ----------------------------------------------------------------------------------------------------------------------------------------------------- //
// ----------------------------------------------------------------------------------------------------------------------------------------------------- //


Module 4:

1) Difference between Cohesion and Coupling ✅

2) Explain SCM Process ❌

3) What is Risk Management? Discuss Common sources of risk in IT projects ✅: Risk management is a systematic process of identifying, assessing, prioritizing, and mitigating risks that could potentially affect the objectives of an organization, project, or activity. It involves understanding the uncertainties and potential events that could impact the achievement of goals, and taking proactive measures to minimize their negative consequences while maximizing opportunities for success. Common sources of risk in IT projects: 

1. Scope Creep: This occurs when the project's scope expands beyond the initial definition without corresponding increases in time, budget, or resources. It often leads to delays, increased costs, and stakeholder dissatisfaction. 

2. Unclear Requirements: Inadequate or ambiguous requirements can lead to misunderstandings between stakeholders and developers, resulting in rework, delays, and dissatisfaction with the final product. 

3. Technological Complexity: Projects involving emerging or complex technologies may encounter difficulties in implementation, integration, or maintenance. Lack of expertise, compatibility issues, and unexpected technical challenges can pose significant risks. 

4. Resource Constraints: Insufficient budget, time, or skilled personnel can hamper project progress and compromise its success. Resource constraints may lead to compromises in quality, scope, or timelines. 

5. Integration Issues: IT projects often involve integrating various systems, applications, or platforms. Integration challenges such as data inconsistency, interoperability issues, and compatibility problems can hinder project progress and functionality. 

6. Security Vulnerabilities: With the increasing frequency and sophistication of cyber threats, security risks pose a significant concern for IT projects. Data breaches, unauthorized access, malware infections, and other security incidents can result in financial losses, reputational damage, and legal liabilities. 

7. Vendor or Third-Party Dependencies: Projects relying on external vendors, contractors, or third-party services are susceptible to risks associated with vendor performance, delivery delays, contractual disputes, and quality assurance. 


4) Describe the details of FTR and Walkthrough ❌

5) Explain SQA activities ✅: 
Software Quality Assurance (SQA) is simply a way to assure quality in the software. It is the set of activities which ensure processes, 
procedures as well as standards are suitable for the  project and implemented correctly. Major Software Quality Assurance Activities:  

	+ SQA Management Plan: 
		Make a plan for how you will carry out the SQA throughout  the project. Think about which set of software engineering activities 
		are the best for project. check level of SQA team skills.  

	+ Set The Check Points: 
		SQA team should set checkpoints. Evaluate the performance of  the project on the basis of collected data on different check 
		points.  

	+ Measure Change Impact: 
		The changes for making the correction of an error sometimes re introduces more errors keep the measure of impact of change on 
		project. Reset the new change to check the compatibility of this fix with whole project.  

	+ Multi testing Strategy: 
		Do not depend on a single testing approach. When you have a lot of testing approaches available use them.  

	+ Manage Good Relations: 
		In the working environment managing good relations with other teams involved in the project development is mandatory. Bad 
		relation of SQA team with programmers’ team will impact directly and badly on project. Don’t play politics.  

	+ Managing Reports and Records: 
		Document and share QA activities (test cases, defects, client changes) for future reference and stakeholder alignment. 

MODULE - 5

1)	Difference between white box and black box testing ✅

2)	Write a short note on Software Supportability. ❌

3)	Explain Software re-engineering in deail ❌

4) Explain Testing strategies for Conventional software ✅:  Software testing is the process of evaluating a software application to identify if it meets 
specified requirements and to identify any defects. The following are common testing strategies: 

1. Black box testing – Tests the functionality of the software without looking at the internal code structure. 

2. White box testing – Tests the internal code structure and logic of the software. 

3. Unit testing – Tests individual units or components of the software to ensure they are  functioning as intended. 

4. Integration testing – Tests the integration of different components of the software to  ensure they work together as a system. 

5. Functional testing – Tests the functional requirements of the software to ensure they are  met. 

6. System testing – Tests the complete software system to ensure it meets the specified requirements. 

7. Acceptance testing – Tests the software to ensure it meets the customer’s or end-user’s  expectations. 

8. Regression testing – Tests the software after changes or modifications have been made to ensure the changes have not introduced new defects. 

9. Performance testing – Tests the software to determine its performance characteristics  such as speed, scalability, and stability. 

10. Security testing – Tests the software to identify vulnerabilities and ensure it meets  security requirements.

Module 6:

1) Explain the Project Charter ✅: A project charter is a formal short document that states a project exists and provides project managers with written authority to begin work and provides essential information to guide its execution. The project charter serves several critical purposes:
	- Authorization: It officially approves the project, granting authority to the project manager and team.
	- Clarity: It defines the project’s scope, objectives, and boundaries.
	- Alignment: It ensures alignment with organizational goals and strategic objectives.
	- Communication: It communicates project details to stakeholders.

2) Explain the 4’PS of Project Management ✅: 
	- People
	- Product
	- Process
	- Project

3) What are the different phases in project life cycle with suitable example ✅: 

- Project Initiation Phase: In this phase, the project’s initial groundwork is laid. The goal is to clarify the project’s scope, objectives, and success criteria. Example: Imagine a software development project where a company wants to create a new mobile app. During initiation, the project team meets with stakeholders, defines the app’s purpose, outlines its features, and sets initial expectations.

- Project Planning Phase: Planning involves creating a detailed roadmap for the project. It includes defining tasks, estimating resources, setting timelines, and creating a project plan. Example: Continuing with our mobile app project, the planning phase would involve creating a Gantt chart, allocating development resources, estimating costs, and determining milestones.

- Project Execution Phase: Execution is where the actual work happens. The project team carries out the planned tasks, develops deliverables, and follows the project schedule. Example: In our mobile app project, developers write code, designers create UI/UX elements, and testers verify functionality. Regular status meetings ensure everyone stays on track.

- Project Monitoring & Controlling Phase: During this phase, project progress is monitored, and adjustments are made as needed. The focus is on tracking performance, managing risks, and ensuring quality. Example: In our app project, the team monitors development progress, checks if milestones are met, and addresses any issues promptly. If a feature is delayed, adjustments are made to the schedule.

- Project Closure Phase: Closure marks the end of the project. It involves finalizing deliverables, conducting user acceptance testing, obtaining client sign-off, and transitioning to maintenance or support. Example: For our mobile app, closure means launching it in app stores, celebrating the successful release, and handing over documentation and support responsibilities to the operations team.   

4) Explain Project Scheduling and describe CPM and PERT ✅: 

	- Project scheduling involves planning and organizing the tasks required to complete a project. It helps project managers allocate resources, 	  	  estimate timeframes, and create a timeline for project execution. Effective project scheduling leads to success of  project, reduced cost, and 	  increased customer satisfaction. Scheduling in project management  means to list out activities, deliverables, and milestones within a project 	  that are delivered. The most common and important  form of project schedule is Gantt chart. 

	- PERT: Programme Evaluation and Review Technique (PERT) is an effective visual network method specifically designed for planning, monitoring, and 	  controlling complex and unique projects. PERT offers a systematic approach that ensures project success by breaking down the entire project into 	  smaller, manageable activities and establishing their interdependencies within a network diagram. The process of developing a PERT involves 		  several key steps: 
		1. Activity Breakdown: The project is carefully dissected into smaller activities, enabling a  more granular analysis and logical sequencing 			of tasks. 
		2. Interdependency Identification: The relationships and dependencies between the  activities are thoroughly examined and accurately 				represented in the network diagram, providing a comprehensive view of the project’s structure. 
		3. Time Estimation: Each activity is assigned three-time estimates: the optimistic or  shortest time, the pessimistic or longest time, and 			the normal or most likely time. These  estimates facilitate a more realistic assessment of activity durations. 
		4. Critical Path Determination: the critical path is the longest sequence of tasks that must be completed to execute a project. It signifies 			the sequence of activities crucial for  timely project completion. Any delays along the critical path directly impact the overall 			project timeline. 
		5. Plan Refinement: Based on the critical path analysis, the initial project plan is carefully  reviewed, modified, and improved to 				effectively control and minimize the time required  for project completion. This ensures that the project stays on track and any 			potential delays are mitigated. 

	- CPM: In project management, the critical path is the longest sequence of tasks that must be completed to execute a project. The tasks on the 	  	  critical path are called critical activities because if they’re delayed, the whole project completion will be delayed. To find the critical path, 	  project managers use the critical path method (CPM). Critical Path Method (CPM) is a project management technique that shares similarities with 	  Programme Evaluation and Review Technique (PERT), but it also has some distinguishing  characteristics: 
		1. Simplified Activity Duration: Unlike PERT, CPM assumes a constant duration for each  activity. Therefore, only a single time estimate is 			assigned to each activity, eliminating  the consideration of uncertainty in duration. 
		2. Emphasis on Cost: While PERT primarily focuses on time management, CPM places a  greater emphasis on cost control. It enables project 			managers to optimize resource  allocation and cost efficiency throughout the project’s execution. 
		3. Well-Known Activity Durations: CPM is more suitable for projects where activity  durations are well-known and can be accurately 				estimated. It is particularly effective in  scenarios where historical data or past project experiences provide reliable information 
			for time estimation.


5)	Explain W5HH principles ✅:
		- Why
		- What
		- When
		- Where
		- Who
		- How
		- How much


























