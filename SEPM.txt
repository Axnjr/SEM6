1. Software engineering: 
is a discipline that involves the application of engineering principles, techniques, and methodologies to the design, development, 
testing, and maintenance of software systems. It encompasses a systematic approach to the entire software development process, aiming to 
create high-quality, reliable, and efficient software solutions that meet user requirements within specified constraints such as time 
and budget. Key characteristics:
	+ Functionalit
	+ Reliability
	+ Efficiency
	+ Scalability
	+ Usability
	+ Maintainability
	+ Portability
	+ Security
	+ Compatibility: 
		Software should be compatible with different hardware platforms, operating systems, and software environments to ensure interoperability and ease of integration with other systems and applications.
Activities:
	Requirements Analysis: Understanding and documenting what the software needs to do.
	Design: Creating a blueprint for the software architecture.
	Implementation: Writing the actual code.
	Testing: Verifying that the software works correctly.
	Maintenance: Keeping the software up-to-date and fixing issues.


2. A software process: 
refers to the methods and techniques used to develop and maintain software.


3. The software development life cycle (SDLC): 
is a structured process that is used to design, develop, and test good-quality software. SDLC, or software development life cycle is a 
methodology that defines the entire procedure of software development step-by-step. The goal of the SDLC life cycle model is to deliver 
high quality, maintainable software that meets the user’s requirements. 


3. Capability maturity model: 
CMM helps assess an organization’s maturity in software development processes. It provides guidelines to enhance process maturity. 
CMM defines five maturity levels, each representing a process capability level.
	Level 1 (Initial): Chaotic processes with no defined structure.
	Level 2 (Repeatable): Basic project management practices.
	Level 3 (Defined): Standardized processes across projects.
	Level 4 (Managed): Quantitatively controlled processes.
	Level 5 (Optimizing): Continuous process improvement
Benefits of CMM:
	Resource Optimization: Efficient use of resources (money, labor, time).
	Benchmarking: Formal framework for self-evaluation and comparison.
	Quality Management: Emphasizes quality assurance and control.
	Process Enhancement: Gradual process improvement.
	Increased Output: Boosts productivity without compromising quality.


4. The Waterfall Model: 
is a classic software development life cycle (SDLC) model that follows a structured, sequential approach for project management and 
software development. We can imagine waterfall in the following way:  
	“ Once the water starts flowing over the edge of the cliff, it starts falling down the mountain and the water cannot go back up ” 
Similarly, waterfall model also works, once one phase of development is completed then we move to the next phase but cannot go back to 
the previous phase. In the waterfall model, the output of one phase serves as the input for the other phase. 

	Phases:
		+ Reuqirements
		+ Design
		+ Implement
		+ Verification
		+ Maintanance

	Advantages:
		Clarity and Simplicity: The linear structure provides a straightforward foundation for project development.
		Suited for projects with clear and stable requirements.
	Disadvantages:
		Inflexible: Changes are difficult once a phase is complete.
		Risk of Late Discoveries: Issues may arise late in the process.
		Not Ideal for Complex Projects: May not handle complex, evolving requirements well.

Iterative waterfall model is an extension of it, which alows Iteratively fixing and improveing the software flexibly.

5. The Prototype Model: 
in software engineering is a developmental approach where a prototype is created, tested, and refined based on feedback. Involves building 
a preliminary version of the final software. This prototype serves as a basic model which refined based on user input.
	Phases:
		+ Reqiurments
		+ Quick Design
		+ Build a prototype
		+ User evaluation
		+ Refining the prototype
		+ Implemnt and maintanance
One problem in this model is that if the end users are not satisfied with the prototype model, then a new prototype model is created 
again, due to which this model consumes a lot of money and time.


6. The V-Model: 
in software engineering is a development process that extends the waterfall model. It emphasizes testing and validation at every stage 
of the development process. The V-Model gets its name from its “V” shape, representing parallel development and testing phases.
Unlike the linear waterfall model, the V-Model bends upward after the coding phase.
	Same Advantages and Disadvantages as of Waterfall model: 
		+ Thorough testing ensures high-quality software


7. Incremental development model: 
First, a simple working system implementing only a few basic features is built and then that is delivered to the customer. Then 
thereafter many successive iterations/ versions are implemented and delivered to the customer until the desired system is released. 


8. The evolutionary model: 
is a combination of the Iterative and Incremental models of the software development life cycle. The Evolutionary Model divides the 
development cycle into smaller, incremental waterfall models. Users get access to the product at the end of each cycle.
Feedback from users helps in planning the next cycle, allowing for changes and adaptations.
The software product evolves over time. This model is suitable for products which are prone to constant redesigns and new feature 
additions. (draw a down flowing diagram with all phases below)
	Phases:
		+ Same till designing
		+ Iterative process:
			+ Develop a version
			+ Deliver the version of product to the user
			+ Take user feedback on it
			+ Incorporate the feedback in the developement
		+ Deliver completed project


9. Spiral model:
This model has characteristics of both of iterative and waterfall model. This model is used in projects which are large and complex.  
It is named as Spiral as in this model we start building the software and then take multiple iterations or loops to deliver the better 
version of the software, its figure, it looks like a spiral, in which a long-curved line starts from the centre point and makes many 
loops around it.  The most special thing about this model is that risks are identified in each phase and they are resolved through 
prototyping. This feature is also called Risk Handling. (draw a spiral diagram with 4 segments like graphs and name all phases)


10. RAD model (rapid application developement):
The methodology of RAD model is similar to that of incremental or waterfall model. It is used for small projects. 
If the project is large then it is divided into many small projects and these small projects are 
planned one by one and completed. In this way, by completing small projects, the large project gets ready quickly. 
In this model large project is divided into multiple small projects each of which are completed indedpendently acc. to the time
deadline and the then all modules are joined together to deliver the final product. The main objective of RAD model is to reuse code, 
components, tools, processes in project development.


10. Concurrent paradigm: 
is a programming paradigm that focuses on executing multiple processes concurrently. It aims to enhance the efficacy and performance of 
software systems by utilizing parallel processing


11. Agile: 
is a project management approach that emphasizes adaptability, collaboration, and continuous improvement. It follows the iterative as 
well as incremental approach that emphasizes the importance of delivering of working product very quickly. Below are steps of agile 
process:
	Requirements Gathering: Define project requirements, evaluate feasibility, and plan time and effort.
	Design: Work with stakeholders to define requirements and create high-level diagrams.
	Construction/Iteration: Developers start working on the project, deploying a working product in stages.
	Testing: Quality Assurance examines the product for bugs.
	Deployment: The product is released to the user environment.
	Feedback: Gather feedback and make improvements
AGILE PRINCIPLES: 
	- CUSTOMER SATISFACTION  
	- WELCOME THE CHANGES  
	- DELIVER WORKING SOFTWARE FREQUENTLY  
	- WORKING TOGETHER DAILY  
	- MOTIVATED INDIVIDUALS  
	- FACE TO FACE CONVERSATION  
	- WORKING SOFTWARE  
	- TECHNICAL EXCELLENCE  
	- SELF ORGANISING  
	- SIMPLICITY
	- SUSTAINABLE DEVELOPEMNT


12. Extreme Programming (XP): 
is an agile software development framework that aims to produce higher quality software without compromising the developer experience.
The extreme programming model recommends taking the best practices that have worked well in the past in program development projects.
Below are the best prcatices that have been recognized in the extreme programming model:
	+ Code reviews
	+ Test-Driven Development
	+ Pair Programming
	+ Coding Standards
	+ Refactoring
	+ Customer Involvement
	+ Incremental Development
	+ Continues integration
	+ Simplicity
	+ Design
	+ Integration testing


13. Scrum: 
is an agile team collaboration framework commonly used in software development and other industries. It provides a structured approach to 
managing complex projects, emphasizing teamwork, transparency, and adaptability. The team working on the project under scrum methodology
consists of:
	Product Owner: Represents stakeholders, defines product requirements, and prioritizes work.
	Scrum Master: Facilitates the Scrum process, removes obstacles, and ensures adherence to Scrum principles.
	Developers: The team responsible for creating the product increment.
A few key terms / events of scrum framework:
	Sprint: During sprints, the Scrum team completes the goals and objectives outlined for that particular time frame.
	Sprint Planning: The team plans for the upcoming sprint.
	Daily Scrum (Stand-up): A daily meeting where team members share progress and discuss any impediments.
	Sprint Review: The team demonstrates completed work to stakeholders.
Scrum decisions are based on observation, experience, and experimentation. The framework encourages learning through small experiments and 
adapting as needed.


// ----------------------------------------------------------------------------------------------------------------------------------- //
																MODULE-2
// ----------------------------------------------------------------------------------------------------------------------------------- //


1. Functional Requirements:
- These are the specific features and behaviors that the system must provide to meet the user’s needs.
- Functional requirements answer the question: “What should the software system do?”, Examples of functional requirements include:
	- User authentication (e.g., login functionality).
	- Order processing (e.g., adding items to a shopping cart).
	- Search functionality (e.g., searching for products).
- These requirements are directly visible in the final product and are typically captured in use cases.


2. Non-Functional Requirements:
- These define the quality attributes that the system must satisfy. They focus on how the system performs rather than what it does.
- These requirements address aspects beyond functionality and deal with issues like:
	- Performance: How quickly the system responds to user requests.
	- Security: Ensuring data protection and access control.
	- Usability: How user-friendly the system is.
	- Reliability: System availability and error handling.
	- Scalability: Handling increased load or users.
	- Maintainability: Ease of maintaining and updating the system.
- Non-functional requirements are often specified by technical experts (e.g., architects, developers).
- They are essential for ensuring a robust and high-quality system.
















































































1) Agile Principles:

	Customer Satisfaction: Prioritize customer satisfaction through early and continuous delivery of valuable software.
	
	Changing Requirements: Welcome changing requirements, even late in the project, to benefit the customer.

	Frequent Deliveries: Deliver working software frequently, with a preference for shorter timescales.

	Collaboration: Business people and developers must work together daily.

	Motivated Individuals: Build projects around motivated individuals, trusting them to get the job done.

	Effective Communication: Face-to-face conversation is the most effective way to convey information within the team.

	Working Software: Measure progress by working software.

	Sustainable Development: Promote sustainable development for sponsors, developers, and users.

	Technical Excellence: Focus on technical excellence and good design.

	Simplicity: Maximize work not done.

	Self-Organizing Teams: Allow self-organizing teams to emerge.

	Reflection and Adaptation: Regularly reflect on effectiveness and adjust behavior.





// ----------------------------------------------------------------------------------------------------------------------------------------------------- //
// ----------------------------------------------------------------------------------------------------------------------------------------------------- //
// ----------------------------------------------------------------------------------------------------------------------------------------------------- //


Module 4:

1) Difference between Cohesion and Coupling ✅

2) Explain SCM Process ❌

3) What is Risk Management? Discuss Common sources of risk in IT projects ✅: Risk management is a systematic process of identifying, assessing, prioritizing, and mitigating risks that could potentially affect the objectives of an organization, project, or activity. It involves understanding the uncertainties and potential events that could impact the achievement of goals, and taking proactive measures to minimize their negative consequences while maximizing opportunities for success. Common sources of risk in IT projects: 

1. Scope Creep: This occurs when the project's scope expands beyond the initial definition without corresponding increases in time, budget, or resources. It often leads to delays, increased costs, and stakeholder dissatisfaction. 

2. Unclear Requirements: Inadequate or ambiguous requirements can lead to misunderstandings between stakeholders and developers, resulting in rework, delays, and dissatisfaction with the final product. 

3. Technological Complexity: Projects involving emerging or complex technologies may encounter difficulties in implementation, integration, or maintenance. Lack of expertise, compatibility issues, and unexpected technical challenges can pose significant risks. 

4. Resource Constraints: Insufficient budget, time, or skilled personnel can hamper project progress and compromise its success. Resource constraints may lead to compromises in quality, scope, or timelines. 

5. Integration Issues: IT projects often involve integrating various systems, applications, or platforms. Integration challenges such as data inconsistency, interoperability issues, and compatibility problems can hinder project progress and functionality. 

6. Security Vulnerabilities: With the increasing frequency and sophistication of cyber threats, security risks pose a significant concern for IT projects. Data breaches, unauthorized access, malware infections, and other security incidents can result in financial losses, reputational damage, and legal liabilities. 

7. Vendor or Third-Party Dependencies: Projects relying on external vendors, contractors, or third-party services are susceptible to risks associated with vendor performance, delivery delays, contractual disputes, and quality assurance. 


4) Describe the details of FTR and Walkthrough ❌

5) Explain SQA activities ✅: Software Quality Assurance (SQA) is simply a way to assure quality in the software. It is the set of activities which ensure processes, procedures as well as standards are suitable for the  project and implemented correctly. Major Software Quality Assurance Activities:  

1. SQA Management Plan: Make a plan for how you will carry out the SQA throughout  the project. Think about which set of software engineering activities are the best for project. check level of SQA team skills.  

2. Set The Check Points: SQA team should set checkpoints. Evaluate the performance of  the project on the basis of collected data on different check points.  

3. Measure Change Impact: The changes for making the correction of an error sometimes re introduces more errors keep the measure of impact of change on project. Reset the new change to check the compatibility of this fix with whole project.  

4. Multi testing Strategy: Do not depend on a single testing approach. When you have a lot of testing approaches available use them.  

5. Manage Good Relations: In the working environment managing good relations with other teams involved in the project development is mandatory. Bad relation of SQA team with programmers’ team will impact directly and badly on project. Don’t play politics.  

6. Managing Reports and Records: Document and share QA activities (test cases, defects, client changes) for future reference and stakeholder alignment. 

Module 5: 

1)	Difference between white box and black box testing ✅

2)	Write a short note on Software Supportability. ❌

3)	Explain Software re-engineering in deail ❌

4) Explain Testing strategies for Conventional software ✅:  Software testing is the process of evaluating a software application to identify if it meets 
specified requirements and to identify any defects. The following are common testing strategies: 

1. Black box testing – Tests the functionality of the software without looking at the internal code structure. 

2. White box testing – Tests the internal code structure and logic of the software. 

3. Unit testing – Tests individual units or components of the software to ensure they are  functioning as intended. 

4. Integration testing – Tests the integration of different components of the software to  ensure they work together as a system. 

5. Functional testing – Tests the functional requirements of the software to ensure they are  met. 

6. System testing – Tests the complete software system to ensure it meets the specified requirements. 

7. Acceptance testing – Tests the software to ensure it meets the customer’s or end-user’s  expectations. 

8. Regression testing – Tests the software after changes or modifications have been made to ensure the changes have not introduced new defects. 

9. Performance testing – Tests the software to determine its performance characteristics  such as speed, scalability, and stability. 

10. Security testing – Tests the software to identify vulnerabilities and ensure it meets  security requirements.

Module 6:

1) Explain the Project Charter ✅: A project charter is a formal short document that states a project exists and provides project managers with written authority to begin work and provides essential information to guide its execution. The project charter serves several critical purposes:
	- Authorization: It officially approves the project, granting authority to the project manager and team.
	- Clarity: It defines the project’s scope, objectives, and boundaries.
	- Alignment: It ensures alignment with organizational goals and strategic objectives.
	- Communication: It communicates project details to stakeholders.

2) Explain the 4’PS of Project Management ✅: 
	- People
	- Product
	- Process
	- Project

3) What are the different phases in project life cycle with suitable example ✅: 

- Project Initiation Phase: In this phase, the project’s initial groundwork is laid. The goal is to clarify the project’s scope, objectives, and success criteria. Example: Imagine a software development project where a company wants to create a new mobile app. During initiation, the project team meets with stakeholders, defines the app’s purpose, outlines its features, and sets initial expectations.

- Project Planning Phase: Planning involves creating a detailed roadmap for the project. It includes defining tasks, estimating resources, setting timelines, and creating a project plan. Example: Continuing with our mobile app project, the planning phase would involve creating a Gantt chart, allocating development resources, estimating costs, and determining milestones.

- Project Execution Phase: Execution is where the actual work happens. The project team carries out the planned tasks, develops deliverables, and follows the project schedule. Example: In our mobile app project, developers write code, designers create UI/UX elements, and testers verify functionality. Regular status meetings ensure everyone stays on track.

- Project Monitoring & Controlling Phase: During this phase, project progress is monitored, and adjustments are made as needed. The focus is on tracking performance, managing risks, and ensuring quality. Example: In our app project, the team monitors development progress, checks if milestones are met, and addresses any issues promptly. If a feature is delayed, adjustments are made to the schedule.

- Project Closure Phase: Closure marks the end of the project. It involves finalizing deliverables, conducting user acceptance testing, obtaining client sign-off, and transitioning to maintenance or support. Example: For our mobile app, closure means launching it in app stores, celebrating the successful release, and handing over documentation and support responsibilities to the operations team.   

4) Explain Project Scheduling and describe CPM and PERT ✅: 

	- Project scheduling involves planning and organizing the tasks required to complete a project. It helps project managers allocate resources, 	  	  estimate timeframes, and create a timeline for project execution. Effective project scheduling leads to success of  project, reduced cost, and 	  increased customer satisfaction. Scheduling in project management  means to list out activities, deliverables, and milestones within a project 	  that are delivered. The most common and important  form of project schedule is Gantt chart. 

	- PERT: Programme Evaluation and Review Technique (PERT) is an effective visual network method specifically designed for planning, monitoring, and 	  controlling complex and unique projects. PERT offers a systematic approach that ensures project success by breaking down the entire project into 	  smaller, manageable activities and establishing their interdependencies within a network diagram. The process of developing a PERT involves 		  several key steps: 
		1. Activity Breakdown: The project is carefully dissected into smaller activities, enabling a  more granular analysis and logical sequencing 			of tasks. 
		2. Interdependency Identification: The relationships and dependencies between the  activities are thoroughly examined and accurately 				represented in the network diagram, providing a comprehensive view of the project’s structure. 
		3. Time Estimation: Each activity is assigned three-time estimates: the optimistic or  shortest time, the pessimistic or longest time, and 			the normal or most likely time. These  estimates facilitate a more realistic assessment of activity durations. 
		4. Critical Path Determination: the critical path is the longest sequence of tasks that must be completed to execute a project. It signifies 			the sequence of activities crucial for  timely project completion. Any delays along the critical path directly impact the overall 			project timeline. 
		5. Plan Refinement: Based on the critical path analysis, the initial project plan is carefully  reviewed, modified, and improved to 				effectively control and minimize the time required  for project completion. This ensures that the project stays on track and any 			potential delays are mitigated. 

	- CPM: In project management, the critical path is the longest sequence of tasks that must be completed to execute a project. The tasks on the 	  	  critical path are called critical activities because if they’re delayed, the whole project completion will be delayed. To find the critical path, 	  project managers use the critical path method (CPM). Critical Path Method (CPM) is a project management technique that shares similarities with 	  Programme Evaluation and Review Technique (PERT), but it also has some distinguishing  characteristics: 
		1. Simplified Activity Duration: Unlike PERT, CPM assumes a constant duration for each  activity. Therefore, only a single time estimate is 			assigned to each activity, eliminating  the consideration of uncertainty in duration. 
		2. Emphasis on Cost: While PERT primarily focuses on time management, CPM places a  greater emphasis on cost control. It enables project 			managers to optimize resource  allocation and cost efficiency throughout the project’s execution. 
		3. Well-Known Activity Durations: CPM is more suitable for projects where activity  durations are well-known and can be accurately 				estimated. It is particularly effective in  scenarios where historical data or past project experiences provide reliable information 
			for time estimation.


5)	Explain W5HH principles ✅:
		- Why
		- What
		- When
		- Where
		- Who
		- How
		- How much


























